<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCubee Video Search System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --dark-bg: #0a0e1a;
            --card-bg: rgba(20, 25, 40, 0.85);
            --border-color: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #b8c5d6;
            --accent-blue: #4facfe;
            --accent-purple: #667eea;
            --accent-pink: #f093fb;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --shadow-light: 0 8px 32px rgba(0, 0, 0, 0.3);
            --shadow-heavy: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        body { 
            background: var(--dark-bg);
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(240, 147, 251, 0.1) 0%, transparent 50%);
            color: var(--text-primary); 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden;
        }
        
        .top-toolbar { position: fixed; top: 0; left: 0; width: 100%; background: rgba(10, 14, 26, 0.95); backdrop-filter: blur(20px); border-bottom: 1px solid var(--border-color); padding: 12px 32px; display: flex; justify-content: space-between; align-items: center; z-index: 100; box-shadow: var(--shadow-light); height: 80px; }
        .toolbar-left, .toolbar-right { display: flex; gap: 24px; align-items: center; }
        
        .app-title { font-size: 1.8rem; font-weight: 700; background: var(--primary-gradient); -webkit-background-clip: text; background-clip: text; color: transparent; display: flex; align-items: center; gap: 12px; text-shadow: 0 0 30px rgba(102, 126, 234, 0.5); }
        .app-logo { height: 65px; width: 65px; border-radius: 0%; object-fit: cover; }
        
        .model-btn-wrapper { position: relative; }
        
        .toolbar-btn {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }
        
        .toolbar-btn .btn-hover-bg { position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: var(--primary-gradient); transition: left 0.3s ease; z-index: 0; }
        .toolbar-btn > span { position: relative; z-index: 1; display: flex; align-items: center; gap: 10px; }
        .toolbar-btn:hover .btn-hover-bg { left: 0; }
        .toolbar-btn:hover { transform: translateY(-2px); border-color: var(--accent-blue); box-shadow: 0 10px 25px rgba(79, 172, 254, 0.3); color: var(--text-primary); }
        .toolbar-btn.active { background: var(--success-gradient); border-color: var(--accent-blue); color: var(--text-primary); font-weight: 600; box-shadow: 0 8px 20px rgba(79, 172, 254, 0.4); }
        
        .model-dropdown { display: none; position: absolute; top: 100%; right: 0; margin-top: 8px; background: var(--card-bg); backdrop-filter: blur(20px); border: 1px solid var(--border-color); border-radius: 12px; box-shadow: var(--shadow-heavy); padding: 12px; z-index: 101; width: 180px; }

        .main-content-wrapper { display: flex; flex-grow: 1; padding-top: 80px; height: 100vh; gap: 2px; }
        #left-search-panel { width: 380px; flex-shrink: 0; background: var(--card-bg); backdrop-filter: blur(20px); border-right: 1px solid var(--border-color); padding: 24px; display: flex; flex-direction: column; box-shadow: var(--shadow-light); }
        #right-results-panel { flex-grow: 1; overflow-y: auto; padding: 24px; background: rgba(10, 14, 26, 0.3); }
        .stages-container { display: flex; flex-direction: column; gap: 24px; padding-top: 24px; overflow-y: auto; padding-right: 12px; flex-grow: 1; }
        .stage-card { background: var(--glass-bg); backdrop-filter: blur(15px); border-radius: 16px; padding: 24px; position: relative; border: 1px solid var(--border-color); box-shadow: var(--shadow-light); flex-shrink: 0; transition: all 0.3s ease; }
        .stage-card:hover { transform: translateY(-4px); box-shadow: var(--shadow-heavy); border-color: var(--accent-blue); }
        .stage-number { position: absolute; top: -14px; left: 0px; background: var(--primary-gradient); width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1.1rem; color: white; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); z-index: 1;}
        .stage-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .query-types { display: flex; gap: 10px; }
        .type-btn { width: 44px; height: 44px; font-size: 1.1rem; background: var(--glass-bg); border: 1px solid var(--border-color); border-radius: 12px; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; align-items: center; justify-content: center; color: var(--text-secondary); position: relative; overflow: hidden; }
        .type-btn::before { content: ''; position: absolute; top: 50%; left: 50%; width: 0; height: 0; background: var(--primary-gradient); transition: all 0.3s ease; transform: translate(-50%, -50%); z-index: -1; }
        .type-btn.active::before { width: 200%; height: 200%; }
        .type-btn.active { background: transparent; border-color: var(--accent-blue); color: var(--text-primary); transform: translateY(-3px); box-shadow: 0 8px 20px rgba(79, 172, 254, 0.3); }
        .type-btn:hover:not(.active) { border-color: var(--accent-purple); color: var(--accent-purple); transform: translateY(-2px); }
        .type-btn[data-type="asr"].active::before { background: var(--secondary-gradient); }
        .type-btn[data-type="asr"].active { border-color: var(--accent-pink); box-shadow: 0 8px 20px rgba(240, 147, 251, 0.3); }
        .delete-stage { background: rgba(244, 63, 94, 0.1); border: 1px solid rgba(244, 63, 94, 0.3); color: #f43f5e; width: 36px; height: 36px; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .delete-stage:hover { background: rgba(244, 63, 94, 0.2); transform: scale(1.1) rotate(5deg); box-shadow: 0 4px 15px rgba(244, 63, 94, 0.3); }
        .stage-options { display: flex; gap: 12px; margin-top: 20px; }
        .option-btn { background: var(--glass-bg); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 8px 16px; border-radius: 10px; font-size: 0.85rem; cursor: pointer; transition: all 0.3s ease; font-weight: 500; }
        .option-btn.active { background: var(--success-gradient); border-color: var(--accent-blue); color: var(--text-primary); font-weight: 600; box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3); }
        .option-btn:hover:not(.active) { border-color: var(--accent-blue); color: var(--accent-blue); transform: translateY(-1px); }
        .panel-controls { display: flex; justify-content: space-between; align-items: center; margin-top: auto; flex-shrink: 0; padding-top: 24px; border-top: 1px solid var(--border-color); }
        .stage-controls { display: flex; gap: 16px; }
        .control-btn { width: 54px; height: 54px; border-radius: 14px; border: 1px solid var(--border-color); background: var(--glass-bg); color: var(--text-secondary); font-size: 1.4rem; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); }
        .control-btn:hover { background: var(--primary-gradient); transform: scale(1.05) translateY(-2px); color: var(--text-primary); border-color: var(--accent-blue); box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4); }
        .search-btn { background: var(--primary-gradient); color: white; border: none; padding: 16px 32px; border-radius: 14px; font-weight: 600; font-size: 1.1rem; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); display: flex; align-items: center; gap: 12px; box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4); position: relative; overflow: hidden; }
        .search-btn::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); transition: left 0.5s; }
        .search-btn:hover::before { left: 100%; }
        .search-btn:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6); }
        .query-input-area { margin-top: 15px; position: relative; }
        .stage-input { width: 100%; padding: 16px 20px; background: var(--glass-bg); backdrop-filter: blur(10px); border: 1px solid var(--border-color); border-radius: 12px; color: var(--text-primary); font-size: 1.0rem; line-height: 1.5; resize: vertical; min-height: 80px; transition: all 0.3s ease; font-family: inherit; }
        .stage-input:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.2); background: rgba(79, 172, 254, 0.05); }
        .stage-input-file { display: none; }
        .image-upload-zone { display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 160px; border: 2px dashed var(--border-color); border-radius: 12px; background: var(--glass-bg); color: var(--text-secondary); cursor: pointer; transition: all 0.3s ease; position: relative; overflow: hidden; backdrop-filter: blur(10px); }
        .image-upload-zone.dragover { border-color: var(--accent-blue); background: rgba(79, 172, 254, 0.1); transform: scale(1.02); }
        .image-upload-zone:hover { border-color: var(--accent-purple); background: rgba(102, 126, 234, 0.05); }
        .image-upload-zone i { font-size: 2.5rem; margin-bottom: 10px; }
        .image-upload-zone p { font-size: 0.9rem; text-align: center; }
        .image-preview { width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; }
        .remove-image-btn { position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(255, 255, 255, 0.3); color: #e2e8f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; font-size: 0.9rem; z-index: 2; }
        .remove-image-btn:hover { background: #ef4444; color: white; border-color: transparent; }
        
        .model-dropdown-item { display: flex; align-items: center; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; }
        .model-dropdown-item:hover { background: var(--glass-bg); }
        .model-dropdown-item input[type="checkbox"] { margin-right: 10px; accent-color: var(--accent-blue); }
        .model-dropdown-item label { cursor: pointer; user-select: none; }
        
        .results-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; }
        .result-item { background: var(--card-bg); backdrop-filter: blur(15px); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); aspect-ratio: 16 / 9; cursor: pointer; position: relative; }
        .result-item:hover { transform: scale(1.03) translateY(-4px); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3); border-color: var(--accent-blue); }
        .result-item img { width: 100%; height: 100%; object-fit: cover; display: block; transition: transform 0.3s ease; }
        .result-item:hover img { transform: scale(1.05); }
        
        .cluster-separator { border: 0; height: 1px; background: var(--border-color); margin: 30px 0 20px 0; }
        .cluster-header { color: var(--accent-blue); font-size: 1.2rem; font-weight: 600; margin-bottom: 16px; padding: 16px 20px; background: var(--glass-bg); backdrop-filter: blur(15px); border-radius: 12px; border: 1px solid var(--border-color); display: flex; align-items: center; gap: 12px; box-shadow: var(--shadow-light); }
        .cluster-header i { font-size: 1.2rem; }
        .cluster-header.asr-header { color: var(--accent-pink); background: rgba(240, 147, 251, 0.05); border-color: rgba(240, 147, 251, 0.2); }
        .sequence-header {
            color: var(--text-secondary);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 20px;
            padding: 12px 18px;
            border-left: 3px solid var(--accent-purple);
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .temporal-cluster-header { color: #e2e8f0; font-size: 1.0rem; font-weight: 500; margin-bottom: 15px; margin-top: 15px; display: flex; align-items: center; gap: 10px; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(20px); z-index: 1000; display: none; align-items: center; justify-content: center; }
        .modal-content { background: var(--card-bg); backdrop-filter: blur(25px); border: 1px solid var(--border-color); width: 90%; max-width: 1200px; max-height: 90vh; border-radius: 20px; box-shadow: var(--shadow-heavy); display: flex; flex-direction: column; }
        .modal-header { padding: 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 1.5rem; color: var(--accent-blue); }
        .modal-close { font-size: 1.5rem; cursor: pointer; color: var(--text-secondary); transition: color 0.2s; }
        .modal-close:hover { color: #ef4444; }
        .modal-body { padding: 25px; display: flex; gap: 30px; overflow-y: auto; }
        .filter-section { flex: 1; display: flex; flex-direction: column; }
        .filter-section-header { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; }
        .filter-section-title { font-size: 1.2rem; color: var(--accent-blue); }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #475569; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background: var(--accent-blue); }
        input:checked + .slider:before { transform: translateX(22px); }
        .filter-controls-container { display: flex; flex-direction: column; gap: 15px; }
        .count-filter-row { display: grid; grid-template-columns: 30px 1fr 120px; align-items: center; gap: 10px; cursor: pointer; padding: 8px; border-radius: 8px; border: 1px solid transparent; transition: background-color 0.2s, border-color 0.2s; }
        .count-filter-row:hover { background-color: rgba(79, 172, 254, 0.1); }
        .count-filter-row.active-row { background-color: rgba(79, 172, 254, 0.15); border-color: rgba(79, 172, 254, 0.4); }
        .count-filter-row.custom { grid-template-columns: 30px 1fr 120px 30px; }
        .count-filter-row input[type=checkbox] { accent-color: var(--accent-blue); width: 18px; height: 18px; cursor: pointer; }
        .count-filter-row label { font-size: 1rem; color: var(--text-primary); }
        .filter-input { background: rgba(10, 14, 26, 0.8); border: 1px solid var(--border-color); color: white; border-radius: 6px; padding: 8px 10px; font-size: 0.95rem; }
        .filter-input:focus { outline: none; border-color: var(--accent-blue); }
        .add-custom-btn, .remove-custom-btn { background: none; border: 1px solid var(--border-color); color: var(--text-secondary); width: 30px; height: 30px; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .add-custom-btn:hover, .remove-custom-btn:hover { border-color: var(--accent-blue); color: var(--accent-blue); }
        #positioningCanvas { background: #1e293b; border-radius: 10px; cursor: crosshair; touch-action: none; }
        .drawn-boxes-list { max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        .drawn-box-item { display: flex; align-items: center; justify-content: space-between; background: #1e293b; padding: 8px; border-radius: 6px; }
        .drawn-box-item.active { border-left: 3px solid var(--accent-blue); }
        .shortcuts-info { font-size: 0.8rem; color: var(--text-secondary); margin-top: 10px; line-height: 1.6; }
        
        #temporalContextModal { z-index: 2000; }
        #imageModal { z-index: 2100; }

        .image-modal-overlay { display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.95); backdrop-filter: blur(20px); align-items: center; justify-content: center; }
        .image-modal-content { margin: auto; display: block; max-width: 90vw; max-height: 90vh; animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1); border-radius: 12px; box-shadow: var(--shadow-heavy); }
        @keyframes modalZoom { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .image-modal-close { position: absolute; top: 20px; right: 40px; color: var(--text-primary); font-size: 24px; font-weight: bold; transition: all 0.3s ease; cursor: pointer; z-index: 2101; background: rgba(0, 0, 0, 0.5); border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); }
        .image-modal-close:hover { color: var(--accent-pink); transform: scale(1.1) rotate(90deg); background: rgba(244, 63, 94, 0.2); }
        
        #temporalContextModal .temporal-modal-content {
            background: var(--dark-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            width: 95%;
            max-width: 1600px;
            height: auto;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-heavy);
            animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #temporalContextModal .temporal-modal-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        #temporalContextModal #temporalModalTitle {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        #temporalContextModal .image-modal-close {
            position: static;
            width: 36px;
            height: 36px;
            font-size: 1.2rem;
        }
        #temporalContextModal .temporal-modal-body {
            padding: 24px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .temporal-grid {
            display: grid;
            /* MODIFICATION: Changed minmax from 320px to 220px to make images smaller */
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 16px;
        }
        .temporal-grid-item {
            position: relative;
            background-color: var(--glass-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16 / 9;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .temporal-grid-item:hover {
            transform: scale(1.05);
            border-color: var(--accent-blue);
            z-index: 10;
        }
        .temporal-grid-item.center-frame {
            border: 2px solid var(--accent-purple);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.6);
        }
        .temporal-grid-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .temporal-item-label {
            position: absolute;
            top: 4px;
            left: 4px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        #temporalContextModal .temporal-modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: var(--primary-gradient); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--secondary-gradient); }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        #loadingIndicator { animation: pulse 2s infinite; color: var(--accent-blue); font-size: 1.4rem;}
        #loadingIndicator i { margin-right: 10px; }
    </style>
</head>
<body>
    <div class="top-toolbar">
        <div class="toolbar-left">
            <div class="app-title">
                <img src="/static/logo.png" alt="OpenCubee Logo" class="app-logo">
                <span>OpenCubee</span>
            </div>
        </div>
        <div class="toolbar-right">
            <div class="model-btn-wrapper">
                <button id="modelSelectBtn" class="toolbar-btn" title="Toggle Models (Ctrl+M)">
                    <div class="btn-hover-bg"></div>
                    <span><i class="fas fa-layer-group"></i> Models</span>
                </button>
                <div id="modelDropdown" class="model-dropdown">
                    <div class="model-dropdown-item"><input type="checkbox" id="model-beit3" value="beit3" checked><label for="model-beit3">BEiT-3</label></div>
                    <div class="model-dropdown-item"><input type="checkbox" id="model-bge" value="bge" checked><label for="model-bge">BGE</label></div>
                    <div class="model-dropdown-item"><input type="checkbox" id="model-unite" value="unite" checked><label for="model-unite">Unite</label></div>
                </div>
            </div>
            
            <button class="toolbar-btn" id="objectFilterBtn" title="Object Filters (Ctrl+F to open, Alt+F to toggle)">
                <div class="btn-hover-bg"></div>
                <span><i class="fas fa-shapes"></i> Filters</span>
            </button>
            <button class="toolbar-btn" id="clusterBtn" title="Toggle Clustering (Ctrl+G)">
                <div class="btn-hover-bg"></div>
                <span><i class="fas fa-object-group"></i> Cluster</span>
            </button>
            <button class="toolbar-btn" id="resetBtn">
                <div class="btn-hover-bg"></div>
                <span><i class="fas fa-redo"></i> Reset Stages</span>
            </button>
            <button class="toolbar-btn" id="exitBtn">
                <div class="btn-hover-bg"></div>
                <span><i class="fas fa-power-off"></i> Exit</span>
            </button>
        </div>
    </div>
    <div class="main-content-wrapper">
        <div id="left-search-panel">
            <div class="stages-container" id="stagesContainer"></div>
            <div class="panel-controls">
                <div class="stage-controls">
                    <button class="control-btn" id="addStageBtn" title="Add Stage (Ctrl+])"><i class="fas fa-plus"></i></button>
                    <button class="control-btn" id="removeStageBtn" title="Remove Stage (Ctrl+[)"><i class="fas fa-minus"></i></button>
                </div>
                <button class="search-btn" id="searchBtn" title="Search (Enter from input)"><i class="fas fa-search"></i> Search</button>
            </div>
        </div>
        <div id="right-results-panel">
            <div id="loadingIndicator" style="display: none; text-align: center; padding: 40px;"><i class="fas fa-spinner fa-spin"></i> Performing Search...</div>
            <div id="resultsContainer"><p style="text-align: center; color: var(--text-secondary); padding-top: 50px; font-size: 1.2rem;">S·ª≠ d·ª•ng b·∫£ng ƒëi·ªÅu khi·ªÉn b√™n tr√°i ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm.</p></div>
        </div>
    </div>
    <div id="objectFilterModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h2 class="modal-title"><i class="fas fa-shapes"></i> Object Filters</h2><span class="modal-close" id="modalCloseBtn">&times;</span></div>
            <div class="modal-body">
                <div class="filter-section">
                    <div class="filter-section-header"><h3 class="filter-section-title">Object Counting</h3><label class="switch"><input type="checkbox" id="enableCountFilter"><span class="slider"></span></label></div>
                    <div id="countFilterControls" class="filter-controls-container"></div>
                     <button class="add-custom-btn" id="addCustomCountBtn" style="margin-top: 15px; width: 100%;"><i class="fas fa-plus"></i> Add Custom Object</button>
                </div>
                <div class="filter-section">
                    <div class="filter-section-header"><h3 class="filter-section-title">Object Positioning</h3><label class="switch"><input type="checkbox" id="enablePositionFilter"><span class="slider"></span></label></div>
                    <div class="position-controls">
                        <canvas id="positioningCanvas" width="640" height="360"></canvas>
                        <div id="drawnBoxesList" class="drawn-boxes-list"></div>
                        <p class="shortcuts-info"><b>Shortcuts:</b> Draw box with mouse. <br><b>1-6:</b> person, car, truck, dog, cat, toaster. <b>7:</b> Custom. <br><b>Backspace:</b> Delete last box. <b>C:</b> Clear all.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="imageModal" class="image-modal-overlay">
        <span class="image-modal-close" title="Close (Esc)">&times;</span>
        <img class="image-modal-content" id="zoomedImage">
    </div>

    <div id="temporalContextModal" class="image-modal-overlay">
        <div class="temporal-modal-content">
            <div class="temporal-modal-header">
                <h2 id="temporalModalTitle"></h2>
                <span class="image-modal-close" id="closeTemporalModalBtn" title="Close (Esc)">&times;</span>
            </div>
            <div class="temporal-modal-body">
                <div class="temporal-grid" id="temporalGrid">
                </div>
            </div>
            <div class="temporal-modal-footer">
                H∆∞·ªõng d·∫´n: Click ƒë·ªÉ zoom, Ctrl+Click ƒë·ªÉ xem b·ªëi c·∫£nh, Ctrl+Shift+Click ƒë·ªÉ t√¨m ki·∫øm b·∫±ng ·∫£nh n√†y.
            </div>
        </div>
    </div>


    <script>
        function urlSafeB64Encode(str) {
            try {
                const utf8Bytes = new TextEncoder().encode(str);
                let binaryString = '';
                utf8Bytes.forEach(byte => {
                    binaryString += String.fromCharCode(byte);
                });
                return btoa(binaryString)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_');
            } catch (e) {
                console.error("Failed to encode string:", str, e);
                return "";
            }
        }
        // Add this debug utility function after the urlSafeB64Encode function (around line 338)
        function debugSearch(type, data) {
            const DEBUG = true; // Set to false to disable all debug output
            if (!DEBUG) return;
            
            const timestamp = new Date().toISOString();
            const separator = "=".repeat(80);
            
            console.log(`\n${separator}`);
            console.log(`%cüîç SEARCH DEBUG: ${type.toUpperCase()} at ${timestamp}`, 
                'color: #4facfe; font-size: 14px; font-weight: bold;');
            console.log(separator);
            
            // Log basic search configuration
            console.log('%cüìã Search Configuration:', 'color: #667eea; font-weight: bold;');
            console.log(data.config);
            
            // Log timing information if available
            if (data.timing) {
                console.log('%c‚è±Ô∏è Timing Information:', 'color: #f093fb; font-weight: bold;');
                console.table(data.timing);
            }
            
            // Log query details
            if (data.query) {
                console.log('%cüî§ Query Details:', 'color: #00f2fe; font-weight: bold;');
                if (typeof data.query === 'string') {
                    console.log(data.query);
                } else {
                    console.log(data.query);
                }
            }
            
            // Log filters
            if (data.filters) {
                console.log('%cüîç Active Filters:', 'color: #fa709a; font-weight: bold;');
                console.log(data.filters);
            }
            
            // Log request payload
            if (data.payload) {
                console.log('%cüì¶ Request Payload:', 'color: #fee140; font-weight: bold;');
                console.log(data.payload);
            }
            
            // Log response data
            if (data.response) {
                console.log('%cüì® Response Data:', 'color: #43e97b; font-weight: bold;');
                console.log(`Status: ${data.response.status || 'N/A'}`);
                if (data.response.data) {
                    console.log('First few results:', data.response.data.slice(0, 3));
                    console.log(`Total results: ${data.response.data.length}`);
                }
            }
            
            console.log(separator);
            console.log(`%cüèÅ END DEBUG: ${type.toUpperCase()}`, 'color: #4facfe; font-weight: bold;');
            console.log(separator);
        }


        document.addEventListener('DOMContentLoaded', () => {
            let currentResults = []; 
            let searchType = null;
            const stagesContainer = document.getElementById('stagesContainer'); 
            const addStageBtn = document.getElementById('addStageBtn'); 
            const removeStageBtn = document.getElementById('removeStageBtn'); 
            const searchBtn = document.getElementById('searchBtn'); 
            const resultsContainer = document.getElementById('resultsContainer'); 
            const loadingIndicator = document.getElementById('loadingIndicator'); 
            const modelSelectBtn = document.getElementById('modelSelectBtn'); 
            const modelDropdown = document.getElementById('modelDropdown'); 
            const clusterBtn = document.getElementById('clusterBtn');
            const objectFilterBtn = document.getElementById('objectFilterBtn');
            const objectFilterModal = document.getElementById('objectFilterModal');
            const modalCloseBtn = document.getElementById('modalCloseBtn');
            const enableCountFilter = document.getElementById('enableCountFilter');
            const enablePositionFilter = document.getElementById('enablePositionFilter');
            const countFilterControls = document.getElementById('countFilterControls');
            const addCustomCountBtn = document.getElementById('addCustomCountBtn');
            const posCanvas = document.getElementById('positioningCanvas');
            const drawnBoxesList = document.getElementById('drawnBoxesList');
            const posCtx = posCanvas.getContext('2d');
            const imageModal = document.getElementById('imageModal');
            const zoomedImage = document.getElementById('zoomedImage');
            const closeImageModalBtn = document.querySelector('#imageModal .image-modal-close');
            let drawnBoxes = [];
            let isDrawing = false;
            let startX, startY, currentX, currentY;
            const PREDEFINED_OBJECTS = ['person', 'car', 'truck', 'dog', 'cat', 'cow', 'toaster'];
            const LABEL_SHORTCUTS = { '1': 'person', '2': 'car', '3': 'truck', '4': 'dog', '5': 'cat', '6': 'toaster'};
            
            const temporalContextModal = document.getElementById('temporalContextModal');
            const temporalGrid = document.getElementById('temporalGrid');
            const temporalModalTitle = document.getElementById('temporalModalTitle');
            const closeTemporalModalBtn = document.getElementById('closeTemporalModalBtn');

            const queryTypes = [{ id: 'text', icon: 'fas fa-font', label: 'Text (Ctrl+H)' }, { id: 'image', icon: 'fas fa-image', label: 'Image (Ctrl+J)' }, { id: 'ocr', icon: 'fas fa-text-height', label: 'OCR (Ctrl+K)' }, { id: 'asr', icon: 'fas fa-microphone', label: 'ASR (Ctrl+L)' }];

            clusterBtn.addEventListener('click', () => { clusterBtn.classList.toggle('active'); if (currentResults.length > 0) displayResults(); }); 
            
            function toggleFilterPanel() {
                const isVisible = objectFilterModal.style.display === 'flex';
                objectFilterModal.style.display = isVisible ? 'none' : 'flex';
            }

            function toggleAllObjectFiltersActiveState() {
                const areAnyFiltersOn = enableCountFilter.checked || enablePositionFilter.checked;
                const newState = !areAnyFiltersOn;
                enableCountFilter.checked = newState;
                enablePositionFilter.checked = newState;
                getObjectFilterData(); 
                console.log(`Object filters toggled to: ${newState ? 'ON' : 'OFF'}`);
            }

            objectFilterBtn.addEventListener('click', toggleFilterPanel);
            modalCloseBtn.addEventListener('click', () => objectFilterModal.style.display = 'none');
            objectFilterModal.addEventListener('click', (e) => { if (e.target === objectFilterModal) objectFilterModal.style.display = 'none'; });

            function createCountRow(objectName = '', isCustom = false) {
                const row = document.createElement('div');
                row.className = 'count-filter-row' + (isCustom ? ' custom' : '');
                const checkboxHTML = `<input type="checkbox" class="count-checkbox" data-object="${objectName || 'custom'}">`;
                const labelHTML = isCustom ? `<input type="text" class="filter-input custom-object-name" placeholder="object name">` : `<label>${objectName}</label>`;
                const conditionHTML = `<input type="text" class="filter-input condition-input" placeholder="e.g., >=1">`;
                const removeBtnHTML = isCustom ? `<button class="remove-custom-btn">&times;</button>` : '';
                row.innerHTML = `${checkboxHTML}${labelHTML}${conditionHTML}${removeBtnHTML}`;
                const checkbox = row.querySelector('.count-checkbox');
                const syncRowStyle = () => row.classList.toggle('active-row', checkbox.checked);
                row.addEventListener('click', (e) => { if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') { checkbox.checked = !checkbox.checked; syncRowStyle(); } });
                checkbox.addEventListener('change', syncRowStyle);
                if (isCustom) row.querySelector('.remove-custom-btn').addEventListener('click', () => row.remove());
                row.querySelectorAll('.filter-input').forEach(input => {
                    input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); checkbox.checked = true; syncRowStyle(); e.target.blur(); } else if (e.key === 'Escape') { e.target.blur(); } });
                });
                syncRowStyle();
                return row;
            }
            PREDEFINED_OBJECTS.forEach(obj => countFilterControls.appendChild(createCountRow(obj)));
            addCustomCountBtn.addEventListener('click', () => countFilterControls.appendChild(createCountRow('', true)));

            function redrawCanvas() {
                if (!posCtx) return;
                posCtx.clearRect(0, 0, posCanvas.width, posCanvas.height);
                posCtx.strokeStyle = 'var(--accent-blue)'; posCtx.lineWidth = 2;
                drawnBoxes.forEach((box, index) => {
                    posCtx.strokeRect(box.x, box.y, box.w, box.h);
                    posCtx.font = "14px 'Poppins'"; posCtx.fillStyle = 'var(--accent-blue)';
                    posCtx.fillText(`${index + 1}: ${box.label || 'no label'}`, box.x + 5, box.y + 16);
                });
                if (isDrawing) { posCtx.strokeStyle = 'var(--accent-pink)'; posCtx.strokeRect(startX, startY, currentX - startX, currentY - startY); }
            }
            function updateDrawnBoxesList() {
                drawnBoxesList.innerHTML = '';
                drawnBoxes.forEach((box, index) => { const item = document.createElement('div'); item.className = 'drawn-box-item'; item.textContent = `Box ${index + 1}: ${box.label || '(unlabeled)'}`; drawnBoxesList.appendChild(item); });
            }
            posCanvas.addEventListener('pointerdown', (e) => { isDrawing = true; startX = e.offsetX; startY = e.offsetY; });
            posCanvas.addEventListener('pointermove', (e) => { if (!isDrawing) return; currentX = e.offsetX; currentY = e.offsetY; redrawCanvas(); });
            posCanvas.addEventListener('pointerup', (e) => {
                if (!isDrawing) return; isDrawing = false; const endX = e.offsetX; const endY = e.offsetY;
                const box = { x: Math.min(startX, endX), y: Math.min(startY, endY), w: Math.abs(endX - startX), h: Math.abs(endY - startY), label: '' };
                if (box.w > 5 && box.h > 5) { drawnBoxes.push(box); }
                redrawCanvas(); updateDrawnBoxesList();
            });
            posCanvas.addEventListener('mouseenter', () => posCanvas.focus());

            function getObjectFilterData() {
                const filters = {};
                if (enableCountFilter.checked) {
                    const conditions = {};
                    countFilterControls.querySelectorAll('.count-filter-row').forEach(row => {
                        const checkbox = row.querySelector('.count-checkbox');
                        if (checkbox.checked) {
                            const conditionInput = row.querySelector('.condition-input').value.trim();
                            if (conditionInput) {
                                let objectName = row.classList.contains('custom') ? row.querySelector('.custom-object-name').value.trim().toLowerCase() : checkbox.dataset.object;
                                if (objectName) conditions[objectName] = conditionInput;
                            }
                        }
                    });
                    if (Object.keys(conditions).length > 0) filters.counting = { conditions };
                }
                if (enablePositionFilter.checked && drawnBoxes.length > 0) {
                    const boxes = drawnBoxes.filter(b => b.label).map(b => ({ label: b.label, box: [ b.x / posCanvas.width, b.y / posCanvas.height, (b.x + b.w) / posCanvas.width, (b.y + b.h) / posCanvas.height ] }));
                    if (boxes.length > 0) filters.positioning = { boxes };
                }
                objectFilterBtn.classList.toggle('active', enableCountFilter.checked || enablePositionFilter.checked);
                
                return (enableCountFilter.checked || enablePositionFilter.checked) && Object.keys(filters).length > 0 ? filters : null;
            }

            modelSelectBtn.addEventListener('click', (event) => { event.stopPropagation(); modelDropdown.style.display = modelDropdown.style.display === 'block' ? 'none' : 'block'; });
            window.addEventListener('click', () => { if (modelDropdown.style.display === 'block') modelDropdown.style.display = 'none'; });
            
            function createStageCard(number) {
                const stageCard = document.createElement('div');
                stageCard.className = 'stage-card';
                stageCard.dataset.stageNumber = number;

                // This is the final, correct HTML structure for a stage card.
                stageCard.innerHTML = `
                    <div class="stage-number">${number}</div>
                    <div class="stage-header">
                        <div class="stage-options">
                            <button class="option-btn" data-option="enhance" title="Enhance Query">Enhance</button>
                            <button class="option-btn" data-option="expand" title="Expand Query">Expand</button>
                        </div>
                        <button class="delete-stage" title="Delete Stage"><i class="fas fa-times"></i></button>
                    </div>

                    <!-- Main Text Query -->
                    <div class="query-input-group" style="margin-top: 15px;">
                        <label class="input-label"><i class="fas fa-font"></i> Text Query</label>
                        <textarea class="stage-input text-query" placeholder="Enter main text query..." rows="3"></textarea>
                    </div>

                    <!-- Image Query -->
                    <div class="query-input-group" style="margin-top: 15px;">
                        <label class="input-label"><i class="fas fa-image"></i> Image Query</label>
                        <label for="file-input-${number}" class="image-upload-zone" style="height: 120px;">
                            <div class="upload-instructions"><i class="fas fa-cloud-upload-alt"></i><p>Drag & drop or <strong>click to upload</strong></p></div>
                            <img class="image-preview" style="display: none;">
                            <button class="remove-image-btn" style="display: none;" title="Remove image"><i class="fas fa-times"></i></button>
                        </label>
                        <input type="file" id="file-input-${number}" class="stage-input-file" accept="image/*">
                    </div>

                    <!-- Filter Toggles -->
                    <div class="filter-toggles" style="margin-top: 15px; display: flex; gap: 10px;">
                        <button class="option-btn" data-filter="ocr"><i class="fas fa-text-height"></i> OCR Filter</button>
                        <button class="option-btn" data-filter="asr"><i class="fas fa-microphone"></i> ASR Filter</button>
                    </div>

                    <!-- Dynamic OCR Input -->
                    <div class="dynamic-input-wrapper" data-wrapper="ocr" style="display: none;">
                        <div class="query-input-group" style="margin-top: 15px;">
                            <input type="text" class="stage-input ocr-query-input" placeholder="Enter text seen in image...">
                        </div>
                    </div>

                    <!-- Dynamic ASR Input -->
                    <div class="dynamic-input-wrapper" data-wrapper="asr" style="display: none;">
                        <div class="query-input-group" style="margin-top: 15px;">
                            <input type="text" class="stage-input asr-query-input" placeholder="Enter spoken words...">
                        </div>
                    </div>
                `;

                // --- Event Listeners for the New Structure ---

                // 1. Logic for the OCR/ASR Toggles
                const textQueryInput = stageCard.querySelector('.text-query');
                stageCard.querySelectorAll('.filter-toggles .option-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        button.classList.toggle('active');
                        const filterType = button.dataset.filter;
                        const wrapper = stageCard.querySelector(`.dynamic-input-wrapper[data-wrapper="${filterType}"]`);
                        const input = wrapper.querySelector('input');

                        if (button.classList.contains('active')) {
                            wrapper.style.display = 'block';
                            input.focus();
                        } else {
                            wrapper.style.display = 'none';
                            input.value = ''; // CRITICAL: Clear value when toggled off.
                            textQueryInput.focus(); // CRITICAL: Move cursor back to main input.
                        }
                    });
                });

                // 2. Logic for Image Uploading
                const handleFileSelect = (file) => {
                    if (file && file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = e => {
                            const previewImage = stageCard.querySelector('.image-preview');
                            const uploadInstructions = stageCard.querySelector('.upload-instructions');
                            const removeImageBtn = stageCard.querySelector('.remove-image-btn');
                            previewImage.src = e.target.result;
                            previewImage.style.display = 'block';
                            uploadInstructions.style.display = 'none';
                            removeImageBtn.style.display = 'flex';
                        };
                        reader.readAsDataURL(file);
                        stageCard.selectedImageFile = file;
                    }
                };
                stageCard.querySelector('.remove-image-btn').addEventListener('click', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    stageCard.querySelector('.stage-input-file').value = '';
                    const previewImage = stageCard.querySelector('.image-preview');
                    const uploadInstructions = stageCard.querySelector('.upload-instructions');
                    const removeImageBtn = stageCard.querySelector('.remove-image-btn');
                    previewImage.src = '';
                    previewImage.style.display = 'none';
                    uploadInstructions.style.display = 'block';
                    removeImageBtn.style.display = 'none';
                    delete stageCard.selectedImageFile;
                });
                stageCard.querySelector('.stage-input-file').addEventListener('change', e => handleFileSelect(e.target.files[0]));
                const dropZone = stageCard.querySelector('.image-upload-zone');
                dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
                dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('dragover'); });
                dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFileSelect(e.dataTransfer.files[0]); });

                // 3. Logic for other buttons
                stageCard.querySelector('.delete-stage').addEventListener('click', () => { stageCard.remove(); renumberStages(); });
                stageCard.querySelectorAll('.stage-options .option-btn').forEach(button => button.addEventListener('click', () => button.classList.toggle('active')));

                return stageCard;
            }
            function renumberStages() { stagesContainer.querySelectorAll('.stage-card').forEach((card, index) => card.querySelector('.stage-number').textContent = index + 1); }
            function addStage() { stagesContainer.appendChild(createStageCard(stagesContainer.children.length + 1)); }
            function removeStage() { if (stagesContainer.children.length > 1) stagesContainer.lastChild.remove(); }
            
            // Replace the existing handleSearch function with this version
            async function handleSearch() {
                const searchStartTime = performance.now();
                console.log("[SEARCH] Starting new search operation");
                
                const allStages = stagesContainer.querySelectorAll('.stage-card');
                if (allStages.length === 0) {
                    alert('Please add at least one search stage.');
                    return;
                }

                loadingIndicator.style.display = 'block';
                resultsContainer.innerHTML = '';

                try {
                    const selectedModels = Array.from(document.querySelectorAll('#modelDropdown input:checked')).map(cb => cb.value);
                    const objectFilters = getObjectFilterData();

                    let response;
                    searchType = null; // This helps the displayResults function format headers correctly

                    // Debug timing data
                    const timing = {
                        start: new Date().toISOString(),
                        preparation: 0,
                        server_request: 0,
                        response_processing: 0,
                        rendering: 0,
                        total: 0
                    };

                    // This is a helper function to read data from a single stage card's new UI
                    const getStageData = (stageElement) => {
                        const ocrToggle = stageElement.querySelector('.option-btn[data-filter="ocr"]');
                        const asrToggle = stageElement.querySelector('.option-btn[data-filter="asr"]');

                        // Only get the query value if the corresponding toggle is active
                        const ocrQuery = (ocrToggle.classList.contains('active'))
                            ? stageElement.querySelector('.ocr-query-input').value.trim()
                            : null;
                        
                        const asrQuery = (asrToggle.classList.contains('active'))
                            ? stageElement.querySelector('.asr-query-input').value.trim()
                            : null;

                        return {
                            query_text: stageElement.querySelector('.text-query').value.trim(),
                            ocr_query: ocrQuery || null, // Ensure null is sent if empty
                            asr_query: asrQuery || null, // Ensure null is sent if empty
                            enhance: stageElement.querySelector('.option-btn[data-option="enhance"]').classList.contains('active'),
                            expand: stageElement.querySelector('.option-btn[data-option="expand"]').classList.contains('active'),
                            has_image: stageElement.selectedImageFile !== undefined
                        };
                    };

                    const prepStart = performance.now();
                    
                    // --- Main Logic Branch: Temporal vs. Unified Search ---
                    // A. TEMPORAL SEARCH (more than one stage)
                    if (allStages.length > 1) {
                        searchType = 'temporal';
                        const stagesData = [];
                        
                        // Debug collection for all stages
                        const stagesDebug = [];
                        
                        for (let i = 0; i < allStages.length; i++) {
                            const stage = allStages[i];
                            const data = getStageData(stage);
                            
                            // Collect debug info for this stage
                            stagesDebug.push({
                                stage_number: i + 1,
                                query_text: data.query_text,
                                has_image: data.has_image,
                                ocr_active: !!data.ocr_query,
                                ocr_query: data.ocr_query,
                                asr_active: !!data.asr_query,
                                asr_query: data.asr_query,
                                enhance: data.enhance,
                                expand: data.expand
                            });
                            
                            // For temporal search, the main text query is mandatory.
                            if (!data.query_text) {
                                throw new Error(`Please fill in the main Text Query for stage ${stage.dataset.stageNumber}.`);
                            }
                            
                            // Adapt the data structure for the TemporalSearchRequest Pydantic model
                            stagesData.push({
                                query: data.query_text,
                                ocr_query: data.ocr_query,
                                asr_query: data.asr_query,
                                enhance: data.enhance,
                                expand: data.expand
                            });
                        }

                        if (selectedModels.length === 0) {
                            throw new Error("Please select at least one model for temporal search.");
                        }

                        const payload = { 
                            stages: stagesData, 
                            models: selectedModels, 
                            filters: objectFilters 
                        };
                        
                        timing.preparation = performance.now() - prepStart;
                        
                        // Debug log for temporal search preparation
                        debugSearch('temporal_search_preparation', {
                            config: {
                                type: 'temporal',
                                stages_count: stagesData.length,
                                models: selectedModels,
                                using_filters: objectFilters !== null
                            },
                            timing: {
                                preparation_ms: timing.preparation.toFixed(2)
                            },
                            query: {
                                stages: stagesDebug
                            },
                            filters: objectFilters,
                            payload: payload
                        });
                        
                        const fetchStart = performance.now();
                        console.log(`[TEMPORAL SEARCH] Sending request with ${stagesData.length} stages`);
                        
                        response = await fetch('/temporal_search', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify(payload) 
                        });
                        
                        timing.server_request = performance.now() - fetchStart;
                        console.log(`[TEMPORAL SEARCH] Server responded in ${timing.server_request.toFixed(2)}ms with status ${response.status}`);
                    
                    // B. UNIFIED SEARCH (only one stage)
                    } else {
                        searchType = 'unified';
                        const firstStage = allStages[0];
                        const stageData = getStageData(firstStage);
                        const imageFile = firstStage.selectedImageFile;

                        const hasVectorQuery = stageData.query_text || imageFile;
                        const hasFilterQuery = stageData.ocr_query || stageData.asr_query;

                        if (!hasVectorQuery && !hasFilterQuery) {
                            throw new Error("Please provide a text query, an image, or an active OCR/ASR filter.");
                        }
                        
                        if (hasVectorQuery && selectedModels.length === 0) {
                            throw new Error("Please select at least one model when using a text or image query.");
                        }

                        const formData = new FormData();
                        // The payload here matches the UnifiedSearchRequest Pydantic model
                        const searchDataPayload = {
                            query_text: stageData.query_text || null,
                            ocr_query: stageData.ocr_query,
                            asr_query: stageData.asr_query,
                            models: selectedModels,
                            enhance: stageData.enhance,
                            expand: stageData.expand,
                            filters: objectFilters
                        };
                        
                        formData.append('search_data', JSON.stringify(searchDataPayload));
                        
                        // Add image if present
                        if (imageFile) {
                            console.log(`[IMAGE SEARCH] Using image: ${imageFile.name} (${(imageFile.size/1024).toFixed(2)}KB)`);
                            formData.append('query_image', imageFile, imageFile.name);
                        }
                        
                        timing.preparation = performance.now() - prepStart;
                        
                        // Determine search subtype for more specific logging
                        let searchSubtype = 'unified';
                        if (imageFile) searchSubtype = 'image';
                        else if (stageData.ocr_query && !stageData.query_text) searchSubtype = 'ocr_only';
                        else if (stageData.asr_query && !stageData.query_text) searchSubtype = 'asr_only';
                        
                        // Debug log for unified search preparation
                        debugSearch(`${searchSubtype}_search_preparation`, {
                            config: {
                                type: searchSubtype,
                                models: selectedModels,
                                using_filters: objectFilters !== null,
                                using_image: imageFile !== undefined,
                                image_details: imageFile ? {
                                    name: imageFile.name,
                                    size: (imageFile.size/1024).toFixed(2) + 'KB',
                                    type: imageFile.type
                                } : null
                            },
                            timing: {
                                preparation_ms: timing.preparation.toFixed(2)
                            },
                            query: {
                                text: stageData.query_text,
                                ocr: stageData.ocr_query,
                                asr: stageData.asr_query,
                                enhance: stageData.enhance,
                                expand: stageData.expand
                            },
                            filters: objectFilters,
                            payload: searchDataPayload
                        });
                        
                        const fetchStart = performance.now();
                        console.log(`[${searchSubtype.toUpperCase()} SEARCH] Sending request`);
                        
                        response = await fetch('/search', { 
                            method: 'POST', 
                            body: formData 
                        });
                        
                        timing.server_request = performance.now() - fetchStart;
                        console.log(`[${searchSubtype.toUpperCase()} SEARCH] Server responded in ${timing.server_request.toFixed(2)}ms with status ${response.status}`);
                    }
                    
                    // --- Process Response (this part is the same for both search types) ---
                    if (!response.ok) { 
                        const err = await response.json(); 
                        throw new Error(err.detail || 'An unknown error occurred on the server.'); 
                    }
                    
                    const parseStart = performance.now();
                    currentResults = await response.json();
                    timing.response_processing = performance.now() - parseStart;
                    
                    console.log(`[SEARCH] Parsed response in ${timing.response_processing.toFixed(2)}ms, found ${currentResults.length} results`);
                    
                    // Debug log for response
                    debugSearch(`${searchType}_search_response`, {
                        config: {
                            type: searchType,
                            models: selectedModels
                        },
                        timing: {
                            server_request_ms: timing.server_request.toFixed(2),
                            response_processing_ms: timing.response_processing.toFixed(2)
                        },
                        response: {
                            status: response.status,
                            data: currentResults,
                            results_count: currentResults.length
                        }
                    });
                    
                    const renderStart = performance.now();
                    displayResults();
                    timing.rendering = performance.now() - renderStart;
                    
                    timing.total = performance.now() - searchStartTime;
                    
                    // Final timing log
                    console.log(`[SEARCH] Total search operation completed in ${timing.total.toFixed(2)}ms`);
                    console.table({
                        'Preparation': timing.preparation.toFixed(2) + 'ms',
                        'Server Request': timing.server_request.toFixed(2) + 'ms',
                        'Response Processing': timing.response_processing.toFixed(2) + 'ms',
                        'Rendering': timing.rendering.toFixed(2) + 'ms',
                        'Total Time': timing.total.toFixed(2) + 'ms'
                    });
                    
                } catch (error) { 
                    console.error("[ERROR] Search failed:", error); 
                    resultsContainer.innerHTML = `<p style="color: #ef4444; font-size: 1.1rem; text-align: center;"><strong>Error:</strong> ${error.message}</p>`; 
                    currentResults = []; 
                } finally { 
                    loadingIndicator.style.display = 'none'; 
                }
            }

            // ===================================================================
            // B·∫ÆT ƒê·∫¶U V√ôNG M√É ƒê√É S·ª¨A L·ªñI THEO Y√äU C·∫¶U
            // ===================================================================
            const handleItemClick = (event, shot) => {
                event.preventDefault();
                event.stopPropagation(); // NgƒÉn s·ª± ki·ªán n·ªïi b·ªçt, ƒë·∫£m b·∫£o kh√¥ng c√≥ click th·ª´a
                
                if (event.ctrlKey && event.shiftKey) {
                    // Ch·ª©c nƒÉng: T√¨m ki·∫øm b·∫±ng ·∫£nh (Ctrl + Shift + Click)
                    performImageSearchFromClick(shot);
                } else if (event.ctrlKey || event.metaKey) {
                    // Ch·ª©c nƒÉng: Xem b·ªëi c·∫£nh (Ctrl + Click)
                    openTemporalContextView(shot);
                } else {
                    // Ch·ª©c nƒÉng: Zoom ·∫£nh b√¨nh th∆∞·ªùng (Click)
                    
                    // MODIFICATION: ƒê√£ x√≥a kh·ªëi if ki·ªÉm tra v√† ƒë√≥ng temporalContextModal.
                    // ƒêi·ªÅu n√†y cho ph√©p c·ª≠a s·ªï zoom m·ªü l√™n tr√™n c·ª≠a s·ªï b·ªëi c·∫£nh.
                    // Tr√¨nh x·ª≠ l√Ω ph√≠m "Esc" s·∫Ω x·ª≠ l√Ω vi·ªác ƒë√≥ng t·ª´ng c·ª≠a s·ªï m·ªôt c√°ch ch√≠nh x√°c.
                    
                    imageModal.style.display = 'flex';
                    zoomedImage.src = shot.url;
                }
            };
            // ===================================================================
            // K·∫æT TH√öC V√ôNG M√É ƒê√É S·ª¨A L·ªñI
            // ===================================================================

            // Replace the existing openTemporalContextView function with this version
            async function openTemporalContextView(shot) {
                if (!shot || !shot.filepath) {
                    alert("L·ªói: D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá ƒë·ªÉ m·ªü b·ªëi c·∫£nh.");
                    return;
                }

                const startTime = performance.now();
                console.log(`[TEMPORAL CONTEXT] Opening for Video: ${shot.video_id}, Frame: ${shot.frame_id}`);

                temporalModalTitle.textContent = `ƒêang t·∫£i b·ªëi c·∫£nh cho Video: ${shot.video_id}, Frame: ${shot.frame_id}...`;
                temporalGrid.innerHTML = '<p style="color: white; text-align: center; padding: 20px;">ƒêang ki·ªÉm tra c√°c ·∫£nh c√≥ s·∫µn tr√™n m√°y ch·ªß...</p>';
                temporalContextModal.style.display = 'flex';

                try {
                    const requestStart = performance.now();
                    console.log(`[TEMPORAL CONTEXT] Checking available frames for: ${shot.filepath}`);
                    
                    const response = await fetch('/check_temporal_frames', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ base_filepath: shot.filepath })
                    });

                    const requestTime = performance.now() - requestStart;
                    console.log(`[TEMPORAL CONTEXT] Server responded in ${requestTime.toFixed(2)}ms with status ${response.status}`);

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Kh√¥ng th·ªÉ ki·ªÉm tra c√°c ·∫£nh tr√™n m√°y ch·ªß.');
                    }

                    const existingFiles = await response.json();
                    console.log(`[TEMPORAL CONTEXT] Found ${existingFiles.length} related frames`);

                    // Debug log
                    debugSearch('temporal_context_view', {
                        config: {
                            type: 'temporal_context',
                            source_frame: {
                                filepath: shot.filepath,
                                video_id: shot.video_id,
                                frame_id: shot.frame_id
                            }
                        },
                        timing: {
                            server_request_ms: requestTime.toFixed(2)
                        },
                        response: {
                            status: response.status,
                            frames_count: existingFiles.length,
                            frames: existingFiles.slice(0, 5) // Log first 5 frames only
                        }
                    });

                    if (existingFiles.length === 0) {
                        temporalGrid.innerHTML = '<p style="color: #ffcccc; text-align: center;">Kh√¥ng t√¨m th·∫•y ·∫£nh n√†o trong b·ªëi c·∫£nh n√†y.</p>';
                        return;
                    }

                    temporalModalTitle.textContent = `B·ªëi c·∫£nh ·∫£nh ‚Äì Video: ${shot.video_id || 'N/A'}, Frame: ${shot.frame_id || 'N/A'}`;
                    temporalGrid.innerHTML = ''; 

                    const centerFrameMatch = shot.filepath.match(/_(\d+)\./);
                    const centerFrameNum = centerFrameMatch ? parseInt(centerFrameMatch[1], 10) : null;

                    const renderStart = performance.now();
                    
                    existingFiles.forEach(currentFilepath => {
                        const encodedPath = urlSafeB64Encode(currentFilepath);
                        if (!encodedPath) return;

                        const imageUrl = `/images/${encodedPath}`;
                        const gridItem = document.createElement('div');
                        gridItem.className = 'temporal-grid-item';

                        const label = document.createElement('div');
                        label.className = 'temporal-item-label';
                        const currentFrameMatch = currentFilepath.match(/_(\d+)\./);
                        if (currentFrameMatch && centerFrameNum !== null) {
                            const currentFrameNum = parseInt(currentFrameMatch[1], 10);
                            const offset = currentFrameNum - centerFrameNum;
                            label.textContent = offset > 0 ? `+${offset}` : `${offset}`;
                            if (offset === 0) {
                                gridItem.classList.add('center-frame');
                            }
                        }

                        const img = document.createElement('img');
                        img.src = imageUrl;
                        img.alt = `Frame from ${shot.video_id}`;
                        img.title = `Click: Zoom\nCtrl+Click: Xem b·ªëi c·∫£nh\nCtrl+Shift+Click: T√¨m ki·∫øm b·∫±ng ·∫£nh n√†y\n\nFile: ${currentFilepath}`;
                        img.onerror = () => { gridItem.style.display = 'none'; };

                        gridItem.appendChild(label);
                        gridItem.appendChild(img);

                        const frameIdMatch = currentFilepath.match(/_(\d+)\.[^.]+$/);
                        const thisSpecificShot = {
                            url: imageUrl,
                            filepath: currentFilepath,
                            video_id: shot.video_id,
                            shot_id: shot.shot_id,
                            frame_id: frameIdMatch ? parseInt(frameIdMatch[1], 10) : null
                        };
                        
                        gridItem.addEventListener('click', (e) => {
                            handleItemClick(e, thisSpecificShot);
                        });

                        temporalGrid.appendChild(gridItem);
                    });

                    const renderTime = performance.now() - renderStart;
                    const totalTime = performance.now() - startTime;
                    
                    console.log(`[TEMPORAL CONTEXT] Rendering completed in ${renderTime.toFixed(2)}ms`);
                    console.log(`[TEMPORAL CONTEXT] Total operation time: ${totalTime.toFixed(2)}ms`);

                } catch (error) {
                    console.error("[ERROR] Temporal context view failed:", error);
                    debugSearch('temporal_context_error', {
                        config: {
                            type: 'temporal_context',
                            source_frame: {
                                filepath: shot.filepath,
                                video_id: shot.video_id,
                                frame_id: shot.frame_id
                            }
                        },
                        error: {
                            message: error.message,
                            stack: error.stack
                        }
                    });
                    
                    temporalGrid.innerHTML = `<p style="color: #ffcccc; text-align: center;">ƒê√£ x·∫£y ra l·ªói: ${error.message}</p>`;
                }
            }

            // Replace the existing performImageSearchFromClick function with this version
            async function performImageSearchFromClick(shot) {
                if (!shot || !shot.url || !shot.filepath) {
                    alert('D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá ƒë·ªÉ t√¨m ki·∫øm b·∫±ng h√¨nh ·∫£nh.');
                    return;
                }
                
                // Timing data
                const searchStartTime = performance.now();
                const timing = {
                    image_loading: 0,
                    preparation: 0,
                    search: 0,
                    total: 0
                };
                
                if (temporalContextModal.style.display === 'flex') {
                    temporalContextModal.style.display = 'none';
                }

                console.log(`[IMAGE SEARCH] Initiating from click on ${shot.filepath}`);
                debugSearch('image_search_click_start', {
                    config: {
                        type: 'image_from_click',
                        source: 'user_click'
                    },
                    query: {
                        image_url: shot.url,
                        filepath: shot.filepath,
                        video_id: shot.video_id,
                        frame_id: shot.frame_id
                    }
                });
                
                const prepStart = performance.now();
                stagesContainer.innerHTML = '';
                addStage();
                const newStage = stagesContainer.querySelector('.stage-card');
                
                // Set up the UI for image search
                newStage.querySelector('.type-btn[data-type="image"]').click();
                const uploadInstructions = newStage.querySelector('.upload-instructions');
                uploadInstructions.innerHTML = '<p>ƒêang t·∫£i ·∫£nh ƒë·ªÉ t√¨m ki·∫øm...</p>';
                timing.preparation = performance.now() - prepStart;

                try {
                    // Load the image
                    const loadStart = performance.now();
                    console.log(`[IMAGE SEARCH] Fetching image from: ${shot.url}`);
                    
                    const response = await fetch(shot.url);
                    if (!response.ok) throw new Error(`Kh√¥ng th·ªÉ t·∫£i ·∫£nh: ${response.statusText}`);
                    const blob = await response.blob();
                    
                    const filename = shot.filepath.split('/').pop() || 'clicked-image.jpg';
                    const imageFile = new File([blob], filename, { type: blob.type });
                    timing.image_loading = performance.now() - loadStart;
                    
                    console.log(`[IMAGE SEARCH] Image loaded in ${timing.image_loading.toFixed(2)}ms: ${filename} (${(blob.size/1024).toFixed(2)}KB)`);

                    // Setup search with loaded image
                    newStage.selectedImageFile = imageFile;
                    
                    const previewImage = newStage.querySelector('.image-preview');
                    const removeImageBtn = newStage.querySelector('.remove-image-btn');
                    
                    previewImage.src = URL.createObjectURL(blob); 
                    previewImage.style.display = 'block';
                    uploadInstructions.style.display = 'none';
                    removeImageBtn.style.display = 'flex';

                    // Debug log before search
                    debugSearch('image_search_from_click_prepared', {
                        config: {
                            type: 'image_from_click'
                        },
                        timing: {
                            preparation_ms: timing.preparation.toFixed(2),
                            image_loading_ms: timing.image_loading.toFixed(2)
                        },
                        query: {
                            image_file: {
                                name: filename,
                                size: (blob.size/1024).toFixed(2) + 'KB',
                                type: blob.type
                            },
                            source_frame: {
                                filepath: shot.filepath,
                                video_id: shot.video_id,
                                frame_id: shot.frame_id
                            }
                        }
                    });

                    // Execute the search
                    const searchStart = performance.now();
                    await handleSearch();
                    timing.search = performance.now() - searchStart;
                    
                    timing.total = performance.now() - searchStartTime;
                    
                    // Final timing log
                    console.log(`[IMAGE SEARCH] Image search from click completed in ${timing.total.toFixed(2)}ms`);
                    console.table({
                        'Preparation': timing.preparation.toFixed(2) + 'ms',
                        'Image Loading': timing.image_loading.toFixed(2) + 'ms',
                        'Search Execution': timing.search.toFixed(2) + 'ms',
                        'Total Time': timing.total.toFixed(2) + 'ms'
                    });

                } catch (error) {
                    console.error('[ERROR] Image search from click failed:', error);
                    debugSearch('image_search_from_click_error', {
                        config: {
                            type: 'image_from_click'
                        },
                        timing: timing,
                        error: {
                            message: error.message,
                            stack: error.stack
                        }
                    });
                    
                    alert(`ƒê√£ x·∫£y ra l·ªói: ${error.message}`);
                    uploadInstructions.parentElement.querySelector('.upload-instructions').style.display = 'block';
                    uploadInstructions.parentElement.querySelector('.upload-instructions p').textContent = 'K√©o & th·∫£ ·∫£nh ho·∫∑c nh·∫•n ƒë·ªÉ ch·ªçn file';
                    uploadInstructions.parentElement.querySelector('.image-preview').style.display = 'none';
                }
            }
        
            function displayResults() {
                resultsContainer.innerHTML = '';
                const data = currentResults;
                if (!Array.isArray(data) || data.length === 0) {
                    resultsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£.</p>';
                    return;
                }
    
                const isClusteredMode = clusterBtn.classList.contains('active');
    
                const createItemTitle = (shot) => {
                    if (!shot) return '';
                    let title = `Click: Zoom\nCtrl+Click: Xem b·ªëi c·∫£nh\nCtrl+Shift+Click: T√¨m ki·∫øm b·∫±ng ·∫£nh n√†y\n\nFilepath: ${shot.filepath || 'N/A'}\nShot ID: ${shot.shot_id || 'N/A'}`;
                    const score = shot.rrf_score || shot.cluster_score || shot.score;
                    if (score) title += `\nScore: ${score.toFixed(4)}`;
                    if (shot.caption_text) title += `\nCaption: ${shot.caption_text}`;
                    return title;
                };
                
                const createItemHTML = (shot) => {
                    if (!shot || !shot.url) return '';
                    return `<img src="${shot.url}" alt="Search Result" title="${createItemTitle(shot)}" loading="lazy" onerror="this.parentElement.style.display='none'">`;
                };
                
                if (searchType === 'temporal') {
                    data.forEach((sequence, index) => {
                        if (index > 0) resultsContainer.appendChild(document.createElement('hr')).className = 'cluster-separator';
                        const seqHeader = document.createElement('div');
                        seqHeader.className = 'sequence-header';
                        seqHeader.innerHTML = `<i class="fas fa-stream"></i> Sequence ${index + 1} (Video: ${sequence.video_id || 'N/A'})`;
                        resultsContainer.appendChild(seqHeader);
    
                        if (isClusteredMode && sequence.clusters) {
                            sequence.clusters.forEach((cluster, clusterIndex) => {
                                const clusterHeader = document.createElement('div');
                                clusterHeader.className = 'temporal-cluster-header';
                                clusterHeader.innerHTML = `<i class="fas fa-object-group"></i> <strong>Stage ${clusterIndex + 1} Cluster:</strong> Shots ${cluster.min_shot_id} - ${cluster.max_shot_id}`;
                                resultsContainer.appendChild(clusterHeader);
                                const grid = document.createElement('div');
                                grid.className = 'results-grid';
                                const sortedShots = [...(cluster.shots || [])].sort((a, b) => a.filepath && b.filepath ? a.filepath.localeCompare(b.filepath) : 0);
                                sortedShots.forEach(shot => {
                                    const item = document.createElement('div');
                                    item.className = 'result-item';
                                    item.innerHTML = createItemHTML(shot);
                                    item.addEventListener('click', (e) => handleItemClick(e, shot));
                                    grid.appendChild(item);
                                });
                                resultsContainer.appendChild(grid);
                            });
                        } else { 
                            const grid = document.createElement('div');
                            grid.className = 'results-grid';
                            (sequence.shots || []).forEach(shot => {
                                const item = document.createElement('div');
                                item.className = 'result-item';
                                item.innerHTML = createItemHTML(shot);
                                item.addEventListener('click', (e) => handleItemClick(e, shot));
                                grid.appendChild(item);
                            });
                            resultsContainer.appendChild(grid);
                        }
                    });
                } 
                else { 
                    let headerText = null;
                    if (searchType === 'ocr') headerText = '<i class="fas fa-text-height"></i> OCR Search Results';
                    if (searchType === 'asr') headerText = '<i class="fas fa-microphone"></i> ASR Search Results';
                    
                    if (headerText) {
                        const header = document.createElement('div');
                        header.className = `cluster-header ${searchType === 'asr' ? 'asr-header' : ''}`;
                        header.innerHTML = headerText;
                        resultsContainer.appendChild(header);
                        resultsContainer.appendChild(document.createElement('hr')).className = 'cluster-separator';
                    }
    
                    if (isClusteredMode) {
                        data.forEach((cluster, index) => {
                            if (index > 0) resultsContainer.appendChild(document.createElement('hr')).className = 'cluster-separator';
                            const clusterHeader = document.createElement('div');
                            clusterHeader.className = 'cluster-header';
                            
                            const bestShot = cluster.best_shot;
                            if (bestShot) {
                                clusterHeader.innerHTML = `<i class="fas fa-object-group"></i> Cluster ${index + 1} (Video: ${bestShot.video_id} - Shot: ${bestShot.shot_id})`;
                            } else {
                                clusterHeader.innerHTML = `<i class="fas fa-object-group"></i> Cluster ${index + 1}`;
                            }

                            resultsContainer.appendChild(clusterHeader);
                            const grid = document.createElement('div');
                            grid.className = 'results-grid';
                            const sortedShots = [...(cluster.shots || [])].sort((a, b) => a.filepath && b.filepath ? a.filepath.localeCompare(b.filepath) : 0);
                            sortedShots.filter(Boolean).forEach(shot => {
                                const item = document.createElement('div');
                                item.className = 'result-item';
                                item.innerHTML = createItemHTML(shot);
                                item.addEventListener('click', (e) => handleItemClick(e, shot));
                                grid.appendChild(item);
                            });
                            resultsContainer.appendChild(grid);
                        });
                    } else {
                        const grid = document.createElement('div');
                        grid.className = 'results-grid';
                        const flatList = data.flatMap(item => item.shots ? item.shots : [item.best_shot]);
                        const uniqueShots = Array.from(new Map(flatList.filter(Boolean).map(shot => [shot.filepath, shot])).values());
                        
                        uniqueShots.forEach(shot => {
                            const item = document.createElement('div');
                            item.className = 'result-item';
                            item.innerHTML = createItemHTML(shot);
                            item.addEventListener('click', (e) => handleItemClick(e, shot));
                            grid.appendChild(item);
                        });
                        resultsContainer.appendChild(grid);
                    }
                }
            }
            
            addStage(); 
            addStageBtn.addEventListener('click', addStage); 
            removeStageBtn.addEventListener('click', removeStage); 
            searchBtn.addEventListener('click', handleSearch);
            document.getElementById('resetBtn').addEventListener('click', () => { 
                if (confirm('Are you sure you want to reset all stages?')) { 
                    stagesContainer.innerHTML = ''; 
                    addStage(); 
                    currentResults = []; 
                    searchType = null; 
                    resultsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding-top: 50px;">S·ª≠ d·ª•ng b·∫£ng ƒëi·ªÅu khi·ªÉn b√™n tr√°i ƒë·ªÉ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm.</p>'; 
                } 
            });
            
            window.addEventListener('keydown', (event) => {
                        const isImageModalVisible = document.getElementById('imageModal').style.display === 'flex';
                        const isTemporalModalVisible = document.getElementById('temporalContextModal').style.display === 'flex';
                        const isObjectModalVisible = document.getElementById('objectFilterModal').style.display === 'flex';

                        // Logic x·ª≠ l√Ω ph√≠m Esc v·ªõi th·ª© t·ª± ∆∞u ti√™n
                        if (event.key === 'Escape') {
                            event.preventDefault(); 

                            // ∆Øu ti√™n 1: ƒê√≥ng c·ª≠a s·ªï Zoom n·∫øu n√≥ ƒëang m·ªü
                            if (isImageModalVisible) {
                                document.getElementById('imageModal').style.display = 'none';
                                return; 
                            }
                            
                            // ∆Øu ti√™n 2: N·∫øu Zoom kh√¥ng m·ªü, ƒë√≥ng c·ª≠a s·ªï B·ªëi c·∫£nh
                            if (isTemporalModalVisible) {
                                document.getElementById('temporalContextModal').style.display = 'none';
                                return;
                            }

                            // ∆Øu ti√™n 3: N·∫øu c·∫£ hai kh√¥ng m·ªü, ƒë√≥ng c·ª≠a s·ªï Filter
                            if (isObjectModalVisible) {
                                document.getElementById('objectFilterModal').style.display = 'none';
                                return;
                            }
                        }

                        // C√°c ph√≠m t·∫Øt kh√°c v·∫´n ho·∫°t ƒë·ªông nh∆∞ c≈©
                        const activeElement = document.activeElement;
                        const isTyping = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
                        const key = event.key.toLowerCase();

                        if (key === 'enter' && !event.shiftKey) {
                            if (isTyping && activeElement.classList.contains('stage-input')) { event.preventDefault(); searchBtn.click(); }
                            return;
                        }
                    
                        if (isObjectModalVisible && !isTyping && drawnBoxes.length > 0) {
                            if (event.key in LABEL_SHORTCUTS) { event.preventDefault(); drawnBoxes[drawnBoxes.length - 1].label = LABEL_SHORTCUTS[event.key]; } 
                            else if (event.key === '7') { event.preventDefault(); const customLabel = prompt("Enter custom object label:", "person"); if (customLabel) drawnBoxes[drawnBoxes.length - 1].label = customLabel.toLowerCase(); } 
                            else if (event.key === 'Backspace') { event.preventDefault(); drawnBoxes.pop(); } 
                            else if (key === 'c') { event.preventDefault(); if (confirm("Clear all drawn boxes?")) drawnBoxes = []; }
                            redrawCanvas(); 
                            updateDrawnBoxesList();
                        }
                    
                        if (event.altKey && key === 'f') { event.preventDefault(); toggleAllObjectFiltersActiveState(); return; }
                    
                        if (event.ctrlKey || event.metaKey) {
                            let handled = true;
                            if (key === 'f') { event.preventDefault(); toggleFilterPanel(); return; }
                            const stageToModify = isTyping ? activeElement.closest('.stage-card') : stagesContainer.querySelector('.stage-card:last-child');
                            switch (key) {
                                case 'm': modelSelectBtn.click(); break;
                                case ']': addStageBtn.click(); break;
                                case '[': removeStageBtn.click(); break;
                                case 'g': clusterBtn.click(); break; 
                                case 'h': stageToModify?.querySelector('.type-btn[data-type="text"]')?.click(); break;
                                case 'j': stageToModify?.querySelector('.type-btn[data-type="image"]')?.click(); break;
                                case 'k': stageToModify?.querySelector('.type-btn[data-type="ocr"]')?.click(); break;
                                case 'l': stageToModify?.querySelector('.type-btn[data-type="asr"]')?.click(); break;
                                case 'q': stageToModify?.querySelector('.option-btn[data-option="enhance"]')?.click(); break;
                                case 'e': stageToModify?.querySelector('.option-btn[data-option="expand"]')?.click(); break;
                                default: handled = false;
                            }
                            if (handled) event.preventDefault();
                        }
                    });
    
            closeImageModalBtn.addEventListener('click', () => { imageModal.style.display = "none"; });
            imageModal.addEventListener('click', (e) => { if (e.target === imageModal) { imageModal.style.display = "none"; } });
            
            closeTemporalModalBtn.addEventListener('click', () => { temporalContextModal.style.display = "none"; });
            temporalContextModal.addEventListener('click', (e) => { if (e.target === temporalContextModal) { temporalContextModal.style.display = "none"; } });
        });
    </script>
</body>
</html>